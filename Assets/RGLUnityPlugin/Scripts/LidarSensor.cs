// Copyright 2022 Robotec.ai.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using Object = System.Object;

namespace RGLUnityPlugin
{
    /// <summary>
    /// Encapsulates all non-ROS components of a RGL-based Lidar.
    /// </summary>
    [RequireComponent(typeof(PointCloudVisualization))]
    public class LidarSensor : MonoBehaviour
    {
        /// <summary>
        /// Sensor processing and callbacks are automatically called in this hz.
        /// </summary>
        [FormerlySerializedAs("OutputHz")]
        [Range(0, 50)] public int AutomaticCaptureHz = 10;

        /// <summary>
        /// Delegate used in callbacks.
        /// </summary>
        /// <param name="outputData">Data output for each hz</param>
        public delegate void OnNewDataDelegate();

        /// <summary>
        /// Called when new data is generated via automatic capture.
        /// </summary>
        public OnNewDataDelegate onNewData;

        /// <summary>
        /// Allows to select one of built-in LiDAR models.
        /// Defaults to a range meter to ensure the choice is conscious.
        /// </summary>
        public LidarModel modelPreset = LidarModel.RangeMeter;

        /// <summary>
        /// Allows to quickly enable/disable gaussian noise.
        /// </summary>
        public bool applyGaussianNoise = true;

        /// <summary>
        /// Encapsulates description of a point cloud generated by a LiDAR and allows for fine-tuning.
        /// </summary>
        public LidarConfiguration configuration = LidarConfigurationLibrary.ByModel[LidarModel.RangeMeter];

        private RGLGraph rglGraph;
        private SceneManager sceneManager;
        private RGLOutputHandle visualizationOutputHandle;
        private PointCloudVisualization pointCloudVisualization;
        private LidarModel? validatedPreset;
        private float timer;

        public void Start()
        {
            sceneManager = FindObjectOfType<SceneManager>();
            if (sceneManager == null)
            {
                // TODO(prybicki): this is too tedious, implement automatic instantiation of RGL Scene Manager
                Debug.LogError($"RGL Scene Manager is not present on the scene. Destroying {name}.");
                Destroy(this);
            }
            OnValidate();

            rglGraph = new RGLGraph();
            rglGraph.SetRays(configuration.GetRayPoses());
            rglGraph.SetRingIds(configuration.laserArray.GetLaserRingIds());
            rglGraph.SetLidarRange(configuration.maxRange);
            visualizationOutputHandle = rglGraph.AddFormat(new [] {RGLField.XYZ_F32}, Matrix4x4.identity);
        }

        public void OnValidate()
        {
            // This tricky code ensures that configuring from a preset dropdown
            // in Unity Inspector works well in prefab edit mode and regular edit mode. 
            bool presetChanged = validatedPreset != modelPreset;
            bool firstValidation = validatedPreset == null;
            if (!firstValidation && presetChanged)
            {
                configuration = LidarConfigurationLibrary.ByModel[modelPreset];
            }
            validatedPreset = modelPreset;
        }

        public void FixedUpdate()
        {
            if (AutomaticCaptureHz == 0.0f)
            {
                return;
            }
            
            timer += Time.deltaTime;

            var interval = 1.0f / AutomaticCaptureHz;
            if (timer + 0.00001f < interval)
                return;
            timer = 0;

            Capture();
            if (onNewData != null)
            {
                onNewData.Invoke();
            }
        }

        public RGLOutputHandle AddFormat(RGLField[] fields, Matrix4x4 transform)
        {
            return rglGraph.AddFormat(fields, transform);
        }

        public int GetData<T>(RGLOutputHandle handle, ref T[] data) where T: unmanaged
        {
            return rglGraph.GetData<T>(handle, ref data);
        }

        public int GetDataRaw(RGLOutputHandle handle, ref byte[] data, int expectedPointSize)
        {
            return rglGraph.GetDataRaw(handle, ref data, expectedPointSize);
        }

        public void Capture()
        {
            sceneManager.DoUpdate();
            rglGraph.SetLidarPosition(gameObject.transform.localToWorldMatrix);
            rglGraph.Run();

            if (GetComponent<PointCloudVisualization>().isActiveAndEnabled == true)
            {
                Vector3[] onlyHits = new Vector3[1];
                rglGraph.GetData<Vector3>(visualizationOutputHandle, ref onlyHits);
                GetComponent<PointCloudVisualization>().SetPoints(onlyHits);
            }
        }
    }
}